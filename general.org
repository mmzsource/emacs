General out-of-the-box emacs information gathered from multiple sources.

* =C= ontrol & =M= eta

The =C= or control key (as for instance in =C-h=) is the ctrl key. The =M= or
Meta key (as for instance in =M-f=) is the alt key

Very often Meta characters are used for operations related to the units defined
by language (words, sentences, paragraphs), while Control characters operate on
basic units that are independent of what you are editing (characters, lines,
etc). For example:

| Keybinding | Description                   |
|------------+-------------------------------|
| =C-f=      | Forward one cursor position   |
| =M-f=      | Forward one word              |
| =C-b=      | Backward one cursor position  |
| =M-b=      | Backward one word             |
| =C-a=      | Move to beginning of line     |
| =M-a=      | Move to beginning of sentence |
| =C-e=      | Move to end of line           |
| =M-e=      | Move to end of sentence       |
|------------+-------------------------------|

* Commands and Functions

A command is a function that is accessible to the user. For a function to be
accessible to the user, it must be /interactive/. An interactive function has
additional properties, rendering it usable through the =M-x= and key bindings.

When you press a key a special command is invoked: =self-insert-command= that
will insert the last typed key. This makes keys and commands 'symmetric':
regular keyboard characters behave in exactly the same way as all other commands
in emacs. This also means keyboard characters can be unbound, rebound and
modified in every way you want to.

* Frames, Windows, Buffers & Modes
** Windows & Frames

In emacs a /window/ is a tiled portion of the /frame/. The /frame/ is what most
window managers call a window. So you can have one or more /windows/ in a
/frame/. Each window displays exactly one /buffer/.

** Buffers

In emacs, /the buffer is the data structure/. All files are buffers, but not all
buffers are files. You can create a buffer for whatever reason and you won't be
asked for a filename. You have to explicitly save it to a file on disk to make
it persist. Types of buffers:

- Text Buffer
- File
- I/O device
- API to other process like bash or python or a clojure repl

Almost all of Emac's own commands act on buffers. So the same commands you use
to move around and edit in emacs are the same once you use behind-the-scenes in
elisp.

Buffers are rarely killed (closed) when no longer needed. That is no problem
since each buffer is only slightly bigger than the byte size of the characters
in it. A typical emacs session lasts weeks between restarts, and having many
hundreds of buffers running is no issue.

Emacs created buffers, or buffers with transient information have * characters
in their names, like *Messages*. User created buffers normally don't have that.

** Modes

Major modes in emacs control how buffers behave. Each buffer will always have
only one major mode. Emacs will almost always find the right major mode
automatically (e.g. by filetype). Additionally you are free to change a buffer's
major mode at any time by typing the command for another one. Minor modes are
typically optional add-ons that you enable for some (or all) of your buffers.

* Key Sequences, prefix keys & complete keys

A /key sequence/ is a series of keyboard or mouse actions. A /complete key/ is a
series of keyboard or mouse actions that /invoke a command/ (e.g. =C-x C-f= to
invoke the =find-file= command). If the sequence of keys is not a complete key,
then you have a /prefix key/ (e.g. =C-x=)

* Universal Argument

Some commands have alternate states. You modify the states by prefixing the
command key sequence with the /universal/ prefix argument: =C-u= . What happens
next depends on the command you're invoking: some have zero, one or more
universal argument states. Command states are merely numbers. =C-u= means '4
times'.

- =C-u a=     → aaaa
- =C-u 10 a=  → aaaaaaaaaa
- =C-u C-u a= → aaaaaaaaaaaaaaaa

| keybinding         | description           |
|--------------------+-----------------------|
| =C-u=              | Digit argument 4      |
| =C-u C-u=          | Digit argument 16     |
| =M-0 /to/ M-9=     | Digit argument 0 to 9 |
| =C-0 /to/ C-9=     | Digit argument 0 to 9 |
| =C-M-0 /to/ C-M-9= | Digit argument 0 to 9 |
| =M--=              | Negative argument     |
| =C-M--=            | Negative argument     |
|--------------------+-----------------------|

Normally =C--= would also be the negative argument, but I've bound that to
resizing the window (zooming out).

Example usage:

| keybinding | description            |
|------------+------------------------|
| =M-d=      | Kill word after point  |
| =M-- M-d=  | Kill word before point |
|------------+------------------------|

* Help

Because I have installed =which-key=, key bindings following the currently typed
incomplete command will display the next possible keys in a popup. So typing
=C-h= will give you all possible help functions (bound to a key).

Furthermore, because I have installed =smex= there will be autocompletion for
commands when using =M-x=. So typing =M-x= and then typing (parts of) your
command, will quickly reveal your options. The selected functions keybinding
can be found (in smex) with =C-h w= (*w* hich key) and its documentation can be found with
=C-h f= (*f* unction description).

A couple of often used help bindings:

| keybinding              | description                                       |
|-------------------------+---------------------------------------------------|
| =C-h C-h=               | help for help                                     |
| =C-h k= =<keybinding>=  | information about the =<keybinding>=              |
| =C-h m=                 | current major mode documentation                  |
| =C-h f= =<function>=    | describe =<function>=                             |
| =C-h a= =<keyword>=     | apropos: list all commands containing =<keyword>= |
| =C-h v=                 | check value of a variable (e.g. user-init-file)   |
| =C-h b=                 | list all key bindings                             |
| =C-h i=                 | open emacs info manual (also =M-x info=)          |
| =F10=                   | Activate menu bar                                 |
| =M-x menu-bar-mode RET= | Show menubar                                      |
|-------------------------+---------------------------------------------------|

* Stop / Exit

| keybinding    | description                                           |
|---------------+-------------------------------------------------------|
| =C-x C-c=     | Stop emacs session (emacs asks which buffers to save) |
| =C-g=         | Discard a command you do not want to finish           |
| =C-g=         | Stop the execution of long running command            |
| =ESC ESC ESC= | Exit out of prompts, regions, prefix args, etc.       |
|---------------+-------------------------------------------------------|

* Undo

- =C-x u= or =C-/= to undo

In out-of-the-box emacs =C-x u= is bound to normal undo, in my case it is bound
to the undo-tree package to visualize and navigate the undo-redo tree and its
branches.

* Save

| keybinding | meaning          |
|------------+------------------|
| =C-x C-s=  | Save buffer      |
| =C-x C-w=  | 'Save as ...'    |
| =C-x s=    | Saving all files |
|------------+------------------|

* Movement

Movement in Emacs is local, regional or global:

- Local: moving around text near point (the cursor)
- Regional: moving around whole functions, class definitions, chapters, etc.
- Global: moving around buffers

** Local & Regional

*** Bindings

| Keybinding             | Purpose                                                                    |
|------------------------+----------------------------------------------------------------------------|
| <left> , <right>, ...  | Arrow keys move by character in all four directions                        |
| =C-<left>= & =C-right= | As above, but by word                                                      |
| =C-<up>= & =C-<down>=  | Move by (list)item, paragraph, header, etc                                 |
| =M-<= & =M->=          | Move to beginning and end of buffer                                        |
|------------------------+----------------------------------------------------------------------------|
| =C-f=                  | Move forward by character                                                  |
| =C-b=                  | Move backward by character                                                 |
| =C-p=                  | Move to previous line                                                      |
| =C-n=                  | Move to next line                                                          |
| =C-8 C-f=              | Move forward 8 characters                                                  |
|------------------------+----------------------------------------------------------------------------|
| =C-a=                  | Move to beginning of the line                                              |
| =C-e=                  | Move to the end of the line                                                |
| =M-m=                  | Move to first non-whitespace char on this line (easy for code indentation) |
|------------------------+----------------------------------------------------------------------------|
| =M-f=                  | Move forward by word  (similar to =C-<right>= )                            |
| =M-b=                  | Move backward by word (similar to =C-<left>= )                             |
|------------------------+----------------------------------------------------------------------------|
| =M-a=                  | Move to beginning of sentence                                              |
| =M-e=                  | Move to end of sentence                                                    |
|------------------------+----------------------------------------------------------------------------|
| =M-}=                  | Move forward to end of paragraph                                           |
| =M-{=                  | Move backward to start of paragraph                                        |
|------------------------+----------------------------------------------------------------------------|

*** Words

The definition of a word depends on the major mode you're in. A /syntax table/
gives every character, directly or indirectly, a particular syntactic meaning.
So in this table things like 'what characters are used for comments, what
characters make up a word' are defined. Every editor has an equivalent of Emac's
syntax table, but emacs is special in the sense that you can inspect and change
the syntax table. You can inspect the current syntax table with the
=describe-syntax= command, bound to =C-h s=.

Apart from changing the syntax table, there are also commands and even minor
modes to easily work with CamelCase and snake_case: =subword-mode= and
=superword-mode= respectively. =glasses-mode= is a minor mode that'll turn
CamelCase words into Camel_Case /visually/. So the actual buffer is left
unchanged, the only thing that changes is what you see.

*** Lines

If a line is long, and is wrapped on your screen into 3 lines, that one *logical
line* is shown as 3 *visual lines* or 3 *screen lines*. After endless debates,
it was decided that the =C-p= and =C-n= commands move by /visual/ lines, not by
logical lines. If you don't like that, you alter you emacs settings by changing
the =line-move-visual= variable.

*** Paragraphs

What a paragraph means is defined by the variables =paragraph-start= and
=paragraph-separate=. =use-hard-newlines= defines whether a hard newline defines
a paragraph.

*** S-Expressions or Balanced Expressions

Things like "...", (...), [...], {...}, etc. can span multiple lines and
are called balanced expressions. What balanced expressions are depends on the
major mode and its syntax table. In emacs it's easy to navigate over balanced
expressions:

| Keybinding | Purpose                                                       |
|------------+---------------------------------------------------------------|
| =C-M-n=    | Move forward to the next list (in the same nested level)      |
| =C-M-p=    | Move backward to the previous list (in the same nested level) |
|------------+---------------------------------------------------------------|
| =C-M-f=    | Move forward by s-expression                                  |
| =C-M-b=    | Move backward by s-expression                                 |
| =C-M-k=    | kill-sexp - kill balanced expression in front of point        |
|------------+---------------------------------------------------------------|
| =C-M-d=    | Move down into a list                                         |
| =C-M-u=    | Move up out of a list                                         |
|------------+---------------------------------------------------------------|
| =C-M-a=    | Move to beginning of defun                                    |
| =C-M-e=    | Move to end of defun                                          |
|------------+---------------------------------------------------------------|

*** Selections and Regions

The region: the contiguous block of text between the point and the mark. You can
set the mark with =C-<SPC>=. The echo area will give you feedback with "Mark
Set." Moving the cursor around will now visually change the region. =C-g= will
deactivate the region. Some commands set a mark automatically (like =M-<= and
=M->=). This way you can easily move back to the old position by using =C-u
C-<SPC>=. More calls to =C-u C-<SPC>= will move you further back in the mark
ring (containing all marks you have placed in a buffer). There is also a
/global mark ring/ for commands that work across buffer boundaries.


If you want to set a mark just to return to it later, you have to:

- Set the Mark =C-<SPC>=
- Deactivate the Region =C-<SPC>=
- Move to any other place
- Return to the place where the mark was set =C-u C-<SPC>=

Precise selections:

| Key Bindings     | Purpose                     |
|------------------+-----------------------------|
| =M-h=            | Marks the next paragraph    |
| =C-M-h=          | Marks the next defun        |
| =C-M-@=          | Marks the next s-expression |
| =C-M-<SPC>=      | Marks the next s-expression |
| =M-@=            | Marks the next word         |
| =C-x h=          | Marks the whole buffer      |
| =C-<SPC>=, =C-g= | Deactivates the region      |
|------------------+-----------------------------|

Mark 2 words: =M-@= =M-@= or =M-2 M-@=. Mark word before point: =M-- M-@=. Mark 2
words before point: =M-- M-2 M-@=.

All mark commands /append to the existing selection/ if you already have a
region active.

Very handy in practice:

| Keybinding      | Purpose               |
|-----------------+-----------------------|
| =C-a C-SPC C-e= | Select whole line     |
| =M-a C-SPC M-e= | Select whole sentence |
| =C-a C-k C-y=   | Copy whole line       |
| =M-a M-k=       | Copy whole sentence   |
| =M-a M-z .=     | Copy whole sentence   |
|-----------------+-----------------------|

*** Scrolling

| Keybinding    | Purpose                             |
|---------------+-------------------------------------|
| =C-v=         | Scroll down a near full screen      |
| =M-v=         | Scroll up a near full screen        |
| =C-M-v=       | Scroll down the /other/ window      |
| =C-M-- C-M-v= | Scroll up the /other/ window        |
| =C-M-S-v=     | Scroll up the /other/ window        |
|---------------+-------------------------------------|
| =M-<=         | Move to the beginning of the buffer |
| =M->=         | Move to the end of the buffer       |
|---------------+-------------------------------------|

When moving to th beginning or the end of the buffer, emacs will
place /the mark/ - an invisible location marker - where you came from , so you
can return to your old position with =C-u C-<SPC>=.

** Global

*** Bindings

| Keybinding    | Meaning                                 |
|---------------+-----------------------------------------|
| =C-x b=       | Switch buffer (default: last visited)   |
| =C-x C-b=     | List running buffers                    |
| =C-x <right>= | Next Buffer                             |
| =C-x <left>=  | Previous Buffer                         |
| =C-x k=       | Kill (close) buffer                     |
|---------------+-----------------------------------------|
| =C-x 0=       | Delete /active/ window                  |
| =C-x 1=       | Delete /other/ windows                  |
| =C-x 2=       | Split window below                      |
| =C-x 3=       | Split window right                      |
| =C-x o=       | Switch active window                    |
| =C-o=         | Switch active window (personal setting) |
|---------------+-----------------------------------------|

I'm also using *IDO* mode and *Winner* mode for easily finding buffers and
easily switching back to previous window configurations. In addition, I'm using
*windmove* to switch between windows. Another nice function is to look at the
recently used files. I've bound that functionality to =C-x C-r= . See
=config.org= file.

Acting on the /other/ window:

| Keybinding  | Purpose                            |
|-------------+------------------------------------|
| =C-x 4 C-f= | Find file in the other window      |
| =C-x 4 d=   | Open dired in the other window     |
| =C-x 4 C-o= | Display buffer in the other window |
| =C-x 4 ...= | ... Act on other window            |
|-------------+------------------------------------|

Acting on another frame:

| Keybinding  | Purpose                           |
|-------------+-----------------------------------|
| =C-x 5 2=   | Create a new frame                |
| =C-x 5 b=   | Switch buffer in /other/ frame    |
| =C-x 5 0=   | Delete /active/ frame             |
| =C-x 5 1=   | Delete /other/ frame              |
| =C-x 5 d=   | Open Dired in the other frame     |
| =C-x 5 o=   | Switch to other frame             |
| =C-x 5 C-o= | Display buffer in the other frame |
|-------------+-----------------------------------|

Notice the similarity in the buffer -, window - and frame keybindings.

*** Bookmarks

Like webbrowser bookmarks, but with wider variety of sources:

- files
- =M-x= dired directories
- =M-x= man pages
- remote files (because of TRAMP)
- etc.

| Keybinding | Purpose            |
|------------+--------------------|
| C-x r m    | Set a book(m)ark   |
| C-x r l    | (l)ist bookmarks   |
| C-x r b    | Jump to (b)ookmark |
|------------+--------------------|

The variable =bookmark-default-file= describes the storage location of our
bookmarks.

Strangly enough, you cannot bookmark eww buffers by default. I understand there
are extensions that have this capability.

*** Registers

Bookmarks are permanent, registers are transient. Registers can store: window
and frameset configs, points, numbers and text.

| Keybinding | Purpose                           |
|------------+-----------------------------------|
| =C-x r s=  | (s)tore region in register        |
| =C-x r i=  | (i)nsert content of register      |
| =C-x r w=  | store (w)indow config in register |
| =C-x r f=  | store (f)rameset in register      |
|------------+-----------------------------------|

A register is a single character only. Might come in handy when you need to copy
and paste multiple regions of text.

** Searching and indexing
*** Isearch

| Keybinding | Purpose                                               |
|------------+-------------------------------------------------------|
| =C-s=      | Begin incremental search                              |
| =C-r=      | Begin backward incremental search                     |
| =C-M-s=    | Begin regexp incremental search                       |
| =C-M-r=    | Begin regexp backward incremental search              |
| =RET=      | Pick the selected match (and marks original position) |
| =C-g=      | Exit ISearch (and return to original position)        |
|------------+-------------------------------------------------------|

- Browse matches with =C-s= (forward) and =C-r= (backward).
- =RET= terminates Isearch, leaves you at the match you are at /and/ it drops a
  mark at your original location. Therefore you can return to your former
  location with the normal =C-u C-<SPC>= keybinding.
- By default, Isearches are not case sensitive, but if you use uppercase letter
  in your search, emacs will switch to case-sensitive search (the so called
  /case folding/)

Isearch history features:

| Keybinding | Purpose                                            |
|------------+----------------------------------------------------|
| =M-n=      | Move to next item in search history                |
| =M-p=      | Move to previous item in search history            |
| =C-M-i=    | "TAB" complete search string against history       |
| =C-s C-s=  | Begins Isearch agains last search string           |
| =C-r C-r=  | Begins backward Isearch against last search string |
|------------+----------------------------------------------------|

Isearch 'string at point' features:

| Keybinding | Purpose                                        |
|------------+------------------------------------------------|
| =C-w=      | Add word at point to search string             |
| =C-y=      | Yank ("paste") from clipboard to search string |
|------------+------------------------------------------------|

Repeated invocations of =C-w= will add subsequent words to the search string.

*** Occur

Grep like utility in emacs to search for regular expressions.

| Keybinding        | Purpose                                                |
|-------------------+--------------------------------------------------------|
| =M-x occur <RET>= | Occur mode                                             |
| =M-s o=           | Occur mode                                             |
| =M-s o=           | Activate occur on current search string inside Isearch |
|-------------------+--------------------------------------------------------|

Use =M-g M-n=, =M-g M-p= to jump /in current buffer/ to next and previous match
displayed in the (other) occur buffer.

Enable context lines (lines before and after the matching line) by customizing
the variable =list-matching-lines-default-context-lines=.

In the occur buffer:

| Keybinding   | Purpose                                          |
|--------------+--------------------------------------------------|
| =M-n=, =M-p= | Go to next and previous occurrence               |
| =<=, =>=     | Go to beginning and end of buffer                |
| =g=          | Revert the buffer, refreshing the search results |
| =q=          | Quits occur mode                                 |
| =e=          | Switches to occur edit mode                      |
| =C-c C-c=    | Apply change and exit occur edit mode            |
|--------------+--------------------------------------------------|

In edit mode, you can edit the matches and commit the changes to their original
lines with =C-c C-c=.

With =M-x multi-occur-in-matching-buffers= and =M-x multi-occur= you can also
search in multiple buffers.

*** Imenu

Jumps to points of interest in each major mode that has defined them. Can be
invoked with =M-x imenu=, but I have added the keybinding =M-i=. Using =<TAB>=,
imenu will suggest points of interest in the current buffer.

*** Ido: Interactively DO things

Will help with completion when finding files or directories or switching
buffers.

*** Grep

| Keybinding      | Purpose                                                                             |
|-----------------+-------------------------------------------------------------------------------------|
| =M-x lgrep=     | Prompts for query and glob pattern to search for with /grep/                        |
| =M-x rgrep=     | Prompts for query and glob pattern to search for recursively with /grep/ and /find/ |
| =M-x rzgrep=    | Like =M-x rgrep= but searches /compressed/ gzip files                               |
|-----------------+-------------------------------------------------------------------------------------|
| =M-x grep=      | Prompts for arguments to pass to /grep/                                             |
| =M-x grep-find= | Prompts for arguments to pass to grep /and/ find                                    |
|-----------------+-------------------------------------------------------------------------------------|

**** Dired - Find by name

M-x find-name-dired

Reads arguments /directory/ and /pattern/ and shows all the files in
/directory/ or its subdirectories whose individual names match
/pattern/.

So to find all .org files in directory ~/Projects and its
subdirectories:

- M-x find-name-dired
- ~/Projects
- *.org
- Put cursor on file you were looking for
- RET

**** Dired - Find text in file

M-x find-grep-dired

Reads arguments /directory/ and /regexp/ and shows all the files in
/directory/ or its subdirectories that contain a match for /regexp/.

So to find the file(s) which contain the text 'directory' in
~/Projects/emacs and its subdirectories:

- M-x find-grep-dired
- ~/Projects
- directory

*** Other movement commands

| Keybinding | Purpose                                                                 |
|------------+-------------------------------------------------------------------------|
| =M-r=      | Re- *position* point to top left, middle left, bottom left              |
| =C-l=      | Re- *center* point to middle, top or bottom in the buffer               |
| =C-M-l=    | Re- *position* the comment or definition so it is in view in the buffer |
| =M-g M-g=  | Go to line                                                              |
| =M-g TAB=  | Go to column                                                            |
| =M-g c=    | Go to character position                                                |
|------------+-------------------------------------------------------------------------|

Jumping to a line or column or char, you can either use the keybinding and then
provide the number when asked for OR use a prefix argument. So if you want to
jump to line 55 you have 2 options:

1. =M-g M-g= 55
2. =M-5 M-5 M-g M-g=

Line numbers can be shown with =M-x linum-mode= . Another option is to use =M-x
line-number-mode= . In my configuration, current line and column number are
displayed in the information line.

* Editing

** Kill Text

| Keybinding        | Purpose                     |
|-------------------+-----------------------------|
| =C-d=             | *Delete* character          |
| =<backspace>=     | *Delete* previous character |
| =M-d=             | Kill word                   |
| =C-<backspace>=   | Kill previous word          |
| =C-k=             | Kill rest of the line       |
| =M-k=             | Kill rest of the sentence   |
| =C-M-k=           | Kill s-expression           |
| =C-S-<backspace>= | Kill current line           |
|-------------------+-----------------------------|

Deleted text is /not/ retained in the kill ring, whereas /killed/ text is.

Keeping the pace with digit arguments:

- Delete 3 next chars:       =C-3 C-d=
- Kill 3 next words:         =M-3 M-d=
- Kill 3 next s-expressions: =C-M-3 C-M-k=

Of course you can also move backwards with the negative argument, like for
instance: =M-- M-d= or =C-- C-d=.

** Clipboard-equivalent commands

| Keybinding | Kill Ring Purpose                              | Clipboard |
|------------+------------------------------------------------+-----------|
| =C-w=      | Kill active region                             | cut       |
| =M-w=      | Copy to kill ring                              | copy      |
| =C-M-w=    | Append kill                                    |           |
| =C-y=      | Yank last kill                                 | paste     |
| =M-y=      | Cycle through kill ring, replacing yanked text |           |
|------------+------------------------------------------------+-----------|

In most editors, there is a clear delineation between clipboard commands – that
act solely and exclusively on the selected text – and commands that delete text.
In Emacs, all commands will kill text straight to your kill ring (with few
exceptions like =<backspace>= and =C-d=).

Kill command rules:

1) *Consecutive kills append* to the kill ring. They will append text in the
   kill ring if the last command was also a kill command. As soon as you use a
   command other than a kill command, the next kill command will make a new
   entry in the kill ring. This is convenient, because you don't have to select
   text first. So =M-d= =M-d= =M-d= (killing 3 words in a row) will lead to 3
   appended words in the kill ring. But =M-d= =M-d= =C-n= =M-d= will have only
   one word in the last kill ring position.
2) *The kill ring can hold many items*. This is convenient, if you want to use
   the kill ring as a temp store for several snippets of code of text.
3) *The kill ring is global* and between all the buffers in emacs. You can view
   the kill ring by running =C-h v kill-ring=.
4) *Killing is also deleting* when you don't care about the killed text. This is
   convenient, because you'll never lose anything.
5) *Marking is unnecessary* for most operations. It's easier to tap =M-d= a few
   times than to mark a region with =M-@= and only then kill it with =C-w=. (For
   copying it is easier to mark and then copy).

** Kill lines

| Keybinding        | Purpose                                    |
|-------------------+--------------------------------------------|
| =C-S-<backspace>= | Kill whole line (no matter where point is) |
| =C-k=             | Kill line from point                       |
|-------------------+--------------------------------------------|

** Yank Text

| Keybinding | Purpose                                       |
|------------+-----------------------------------------------|
| =C-y=      | Yank last kill                                |
| =M-y=      | Cycle through kill ring replacing yanked text |
|------------+-----------------------------------------------|

** Transpose

| Keybinding                 | Purpose                 |
|----------------------------+-------------------------|
| =C-t=                      | Transpose characters    |
| =M-t=                      | Transpose words         |
| =C-M-t=                    | Transpose s-expressions |
|----------------------------+-------------------------|
| =C-x C-t=                  | Transpose lines         |
| =M-x transpose-paragraphs= | Transpose paragraphs    |
| =M-x transpose-sentences=  | Transpose sentences     |
|----------------------------+-------------------------|

** Filling

| Keybinding           | Purpose                           |
|----------------------+-----------------------------------|
| =M-q=                | Refills the paragraph point is in |
| =C-x f=              | Sets the fill column width        |
| =C-x .=              | Sets the fill prefix              |
| =M-x auto-fill-mode= | Toggles auto-filling              |
|----------------------+-----------------------------------|

- Use =M-q= in on normal textual paragraphs, but also on code comments; most
  major modes set a 'best practice' fill width for that programming language or
  file type.
- Use =C-u= before =M-q= and emacs will also try to justify the text (!)
- Use =C-x f= to insert a different paragraph width than the default one.
- Use =C-x .= to set a fill prefix. For instance, if you want to prefix the
  whole paragraph with "    ", you set that as a fill prefix and =M-q= the
  paragraph. To undo the fill prefix, type =C-x .= in an empty line.

** Commenting

| Keybinding        | Purpose                                                |
|-------------------+--------------------------------------------------------|
| =M-;=             | Comment or uncomment DWIM                              |
| =C-x C-;=         | Comment or uncomment line                              |
| =M-x comment-box= | Comment the region but as a box                        |
| =M-j=             | Insert newline and continue with comment on a new line |
| =C-M-j=           | Insert newline and continue with comment on a new line |
|-------------------+--------------------------------------------------------|

Some variables to control comments: ~comment-style~, ~comment-styles~,
~comment-start~, ~comment-end~, ~comment-padding~. Also useful when working in
teams.

** Search and Replace

You can search and replace with or without regexp. In addition, you can also
search and replace from inside or outside Isearch.

| Keybinding           | Purpose                         |
|----------------------+---------------------------------|
| =M-%=                | Query search and replace        |
| =C-M-%=              | Query regexp search and replace |
| =M-x replace-string= | Search and  replace             |
| =M-x replace-regexp= | Regexp search and replace       |
|----------------------+---------------------------------|

Access from within iSearch:

| Isearch keybinding | Purpose                         |
|--------------------+---------------------------------|
| =C-M-%=            | Query regexp search and replace |
| =M-%=              | Query search and replace        |
|--------------------+---------------------------------|

Interactive Query commands:

| Query keybinding | Purpose                            |
|------------------+------------------------------------|
| =SPC= or =y=     | Replaces one match, then continues |
| =.=              | Replaces one match, then exits     |
| =,=              | Replace, but stay at current match |
| =RET= or =q=     | Exits without replacing match      |
| =!=              | Replaces all matches in buffer     |
| =^=              | Moves point back to previous match |
| =u= or =U=       | Undo last / all replacement(s)     |
|------------------+------------------------------------|

Emacs handling of cases is quite smart. In a normal 'lowercase' search and
replace action, it will preserve the case of each replacement. So replacing
'hello' with 'goodbye' will result in replacing 'HELLO' with 'GOODBYE'. And if
you search for 'Hello' or 'HELLO' emacs will /only/ replace those literal
matches because they contain uppercase characters.

** Regexp

TBD? I don't use it that often; regexp is Write Once, Never Read again. Well,
ok, you can read it, but understanding it is a different thing all together!

** Case Change

Case commands acting on regions:

| Keybinding                   | Purpose                |
|------------------------------+------------------------|
| =C-x C-u=                    | Uppercase the region   |
| =C-x C-l=                    | Lowercase the region   |
| =M-x upcase-initials-region= | Capitalizes the region |
|------------------------------+------------------------|

Case commands acting on words:

| Keybinding | Purpose                     |
|------------+-----------------------------|
| =M-c=      | *C*apitalizes the next word |
| =M-u=      | *U*ppercases the next word  |
| =M-l=      | *L*owercase the next word   |
|------------+-----------------------------|

Digit- and negative commands also work (of course). So =M-- M-u= will uppercase
the last word you wrote. You don't have to release the meta key between
keystrokes. So =M-b M-- M-u= is typed with your thumb on the meta key all the
time and then simply =b - u= to move back one word, and uppercase the word
before that.

** Counting Things

Emacs can count a lot of things for you, the most used ones being

- =M-x count-words= and
- =M-x count-matches=

To see what emacs can count, it's best to use apropos help: =C-h a= 'count'.

** Keyboard Macros

| Keybinding      | Purpose               |
|-----------------+-----------------------|
| =F3=            | Start Macro Recording |
| =F4=            | Stop Macro Recording  |
| =C-x e= or =F4= | Play last macro       |
|-----------------+-----------------------|

Sometimes I have to convert a normal list into an org checklist:

- Normal
- List
- To
- Checklist
- Conversion
- Demo

Starting with point on the first listitem, start macro recording
with =F3=. The macro:

- =C-a C-f C-f= (move to the beginning of the line and move forward twice)
- =[ ] =        (insert empty checkbox)
- =C-n=         (move to the next line)

Then type =F4= to stop recording. Now you can run the macro by pressing =F4=
again, or use =C-x e= (and repetitive e's to repeat the macro). (After testing
this macro, practice by creating a normal list out of the checklist again.)

It's also possible to use a digits argument, e.g. =M-5 F4= or =C-5 F4= to
execute the macro 5 times in a row. Passing digit 0 will run the macro over and
over again until it terminates with an error (such as reaching the end of a
buffer).

Emacs has a lot more macro capacities under the hood. The =C-x C-k= prefix will
show the possibilities (bound to keys), because I'm using the which-key package.

** Indenting

Emacs will insert a newline character when you press =RET= but it will also
invoke the major mode's indentation engine (thanks to ~electric-indent-mode~)
which (depending on your major mode) will indent your file correctly.

Pressing TAB will call the =indent-for-tab-command= which is a proxy that
indents your code or attempts to TAB-complete the word at the point. Major modes
can (and do) override the indent command and that's why TAB mostly does what you
mean.

** Sorting

Use =M-x sort-lines= to sort lines alphabetically. Calling with a universal
argument will reverse sort order.

In org mode, use =C-c ^= in a table column and it will ask you how you want the
table to be sorted.

** Aligning

| Command             | Description                         |
|---------------------+-------------------------------------|
| =M-x align=         | Aligns regions based on align rules |
| =M-x align-current= | Aligns section based on align rules |
| =M-x align-regexp=  | Aligns region based on regexp       |
|---------------------+-------------------------------------|

With align you can align assignments and lists based on the current major mode.
Also in text mode aligning can be valuable:

Cappuccino $2.00
Caramel Latte $2.30
Americano $3.50
Macchiato $4.00

=M-x align-regexp \$= results in:

Cappuccino	$2.00
Caramel Latte	$2.30
Americano	$3.50
Macchiato	$4.00

(although working with org mode tables might be a lot easier and powerful in
these cases)

** Zapping

To kill to an arbitrary character, use te /zap/ command =M-z=. Useful when you
want to kill the characters between quotes, kill a piece of text between slashes,
killing a sentence =M-z .= (can also be done with =M-k=), killing an XML tag
=M-z >=, etc.

It kills up-to the specified char. If you want to kill the text between these
quotes "Sometext" (assuming point is on =S=), simply type =M-z ""=,
the first ="= indicating the char to zap to and the second ="= reinserting a
="= . An alternative would be to zap to =t= twice with either =M-z t M-z t= or
with =M-2 M-z t=. I prefer the =M-z ""= solution, because it requires less
thinking; you simply zap up to a char.

** Spell Checking

I use flyspell to check words while typing. After =brew install aspell= the
spelling dependency, I have configured it in my configuration file to work for
all text modes (except a few). For code you should use =M-x flyspell-prog-mode=
which will limit the spell checking to comments, strings and doc strings.

| Keys and Commands        | Description                                    |
|--------------------------+------------------------------------------------|
| =M-$=                    | Spell checks word at the point                 |
| =M-x flyspell-mode=      | Minor mode that highlights spelling errors     |
| =M-x flyspell-prog-mode= | Only highlights strings, docstrings & comments |
| =M-x ispell-buffer=      | Run spell check on buffer                      |
| =M-x ispell-region=      | Run spell check on region                      |
|--------------------------+------------------------------------------------|

In check mode, you can type =i= to add a word to your personal library.

More flyspell info can be found [[https://www.emacswiki.org/emacs/FlySpell][here.]] (including how to switch easily between
dictionaries).

** Quoted insert

To insert a literal ASCII control character, use =C-q= or 'quoted insert'. For
instance, =C-q ESC= inserts the ASCII control code =^[= also known as ESC.

* Calc

Might come in handy =M-x calc=. For info you might want to read [[https://blog.markhepburn.com/2013/12/07/andrew-hyatts-emacs-calc-tutorials][some emacs calc
tutorials]], but don't forget the mode help, the tutorial in emacs and the manual
info pages on the web.

* Smile

- =M-x blackbox=
- =M-x doctor=
- =M-x emacs-uptime=
- =M-x fireplace=
- =M-x lunar-phases=
- =M-x morse-region= & =M-x unmorse-region=
- =M-x pong=
- =M-x snake=
- =M-x tetris=
